:DOC-CONFIG:
# Tangle by default to config.el, which is the most common case
#+property: header-args:emacs-lisp :tangle config.el
#+property: header-args :mkdirp yes :comments no
#+startup: fold
:END:
#+title: Doom Emacs configuration
#+author: Giuseppe Ragusa
#+email: giuseppe.ragusa@gmail.com

[[file:splash/doom-emacs-bw-light.svg]]

This is my Doom Emacs configuration. From this org file, all the necessary Doom Emacs config files are generated.

This file is written in [[https://leanpub.com/lit-config][literate programming style]] using [[https://orgmode.org/][org-mode]]. See [[file:init.el][init.el]], [[file:packages.el][packages.el]] and [[file:config.el][config.el]] for the generated files. You can see this in a nicer format on my blog post [[https://zzamboni.org/post/my-doom-emacs-configuration-with-commentary/][My Doom Emacs configuration, with commentary]].

* Table of Contents :TOC_3:noexport:
- [[#references][References]]
- [[#doom-config-file-overview][Doom config file overview]]
  - [[#config-file-headers][Config file headers]]
  - [[#customized-variables][Customized variables]]
- [[#doom-modules][Doom modules]]
- [[#general-configuration][General configuration]]
  - [[#keybindings][Keybindings]]
  - [[#visual-session-and-window-settings][Visual, session and window settings]]
  - [[#key-bindings][Key bindings]]
    - [[#miscellaneous-keybindings][Miscellaneous keybindings]]
    - [[#emulating-vis--key][Emulating vi's =%= key]]
- [[#org-mode][Org mode]]
  - [[#general-org-configuration][General Org Configuration]]
  - [[#org-visual-settings][Org visual settings]]
  - [[#latex-exporter][Latex exporter]]
  - [[#capturing-and-note-taking][Capturing and note taking]]
  - [[#capturing-images][Capturing images]]
  - [[#capturing-links][Capturing links]]
    - [[#capturing-and-creating-internal-org-links][Capturing and creating internal Org links]]
    - [[#capturing-links-to-external-applications][Capturing links to external applications]]
  - [[#tasks-and-agenda][Tasks and agenda]]
  - [[#gtd][GTD]]
    - [[#capture-templates][Capture templates]]
  - [[#exporting-a-curriculum-vitae][Exporting a Curriculum Vitae]]
  - [[#blogging-with-hugo][Blogging with Hugo]]
  - [[#code-for-org-mode-macros][Code for org-mode macros]]
  - [[#reformatting-an-org-buffer][Reformatting an Org buffer]]
  - [[#avoiding-non-org-mode-files][Avoiding non-Org mode files]]
  - [[#revealjs-presentations][Reveal.js presentations]]
  - [[#programming-org][Programming Org]]
- [[#coding][Coding]]
    - [[#general-coding][General Coding]]
    - [[#julia][Julia]]
    - [[#r][R]]
    - [[#latex][Latex]]
- [[#other-tools][Other tools]]

* References

Emacs config is an art, and I have learned a lot by reading through other people's config files, and from many other resources. These are some of the best ones (several are also written in org mode). You will find snippets from all of these (and possibly others) throughout my config.

- [[http://pages.sachachua.com/.emacs.d/Sacha.html][Sacha Chua's Emacs Configuration]]
- [[https://github.com/daedreth/UncleDavesEmacs#user-content-ido-and-why-i-started-using-helm][Uncle Dave's Emacs config]]
- [[https://github.com/PythonNut/emacs-config][PythonNut's Emacs config]]
- [[https://www.masteringemacs.org/][Mastering Emacs]]
- [[https://tecosaur.github.io/emacs-config/config.html][Tecosaur's Emacs config]]

Note: a lot of manual configuration has been rendered moot by using Emacs Doom, which aggregates a well-maintained and organized collection of common configuration settings for performance optimization, package management, commonly used packages (e.g. Org) and much more.
* Doom config file overview

Doom Emacs uses three config files:

- =init.el= defines which of the existing Doom [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#modules][modules]] are loaded. A Doom module is a bundle of packages, configuration and commands, organized into a unit that can be toggled easily from this file.
- =packages.el= defines which [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#package-management][packages]] should be installed, beyond those that are installed and loaded as part of the enabled modules.
- =config.el= contains all [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#configuring-doom][custom configuration]] and code.

There are other files that can be loaded, but theses are the main ones. The load order of different files is [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#load-order][defined depending on the type of session]] being started.

All the config files are generated from this Org file, to try and make its meaning as clear as possible. All =package!= declarations are written to =packages.el=, all other LISP code is written to =config.el=.

** Config file headers

We start by simply defining the standard headers used by the three files. These headers come from the initial files generated by =doom install=, and contain either some Emacs-LISP relevant indicators like =lexical-binding=, or instructions about the contents of the file.

#+html: <details><summary>init.el</summary>
#+begin_src emacs-lisp :tangle init.el
;;; init.el -*- lexical-binding: t; -*-

;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file located at
;; https://gitlab.com/zzamboni/dot-doom/-/blob/master/doom.org
;; You should make any changes there and regenerate it from Emacs org-mode
;; using org-babel-tangle (C-c C-v t)

;; This file controls what Doom modules are enabled and what order they load
;; in. Remember to run 'doom sync' after modifying it!

;; NOTE Press 'SPC h d h' (or 'C-h d h' for non-vim users) to access Doom's
;;      documentation. There you'll find a "Module Index" link where you'll find
;;      a comprehensive list of Doom's modules and what flags they support.

;; NOTE Move your cursor over a module's name (or its flags) and press 'K' (or
;;      'C-c c k' for non-vim users) to view its documentation. This works on
;;      flags as well (those symbols that start with a plus).
;;
;;      Alternatively, press 'gd' (or 'C-c c d') on a module to browse its
;;      directory (for easy access to its source code).
#+end_src
#+html: </details>

#+html: <details><summary>packages.el</summary>
#+begin_src emacs-lisp :tangle packages.el
;; -*- no-byte-compile: t; -*-
;;; $DOOMDIR/packages.el

;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file located at
;; https://gitlab.com/zzamboni/dot-doom/-/blob/master/doom.org
;; You should make any changes there and regenerate it from Emacs org-mode
;; using org-babel-tangle (C-c C-v t)

;; To install a package with Doom you must declare them here and run 'doom sync'
;; on the command line, then restart Emacs for the changes to take effect -- or
;; use 'M-x doom/reload'.

;; To install SOME-PACKAGE from MELPA, ELPA or emacsmirror:
;;(package! some-package)

;; To install a package directly from a remote git repo, you must specify a
;; `:recipe'. You'll find documentation on what `:recipe' accepts here:
;; https://github.com/raxod502/straight.el#the-recipe-format
;;(package! another-package
;;  :recipe (:host github :repo "username/repo"))

;; If the package you are trying to install does not contain a PACKAGENAME.el
;; file, or is located in a subdirectory of the repo, you'll need to specify
;; `:files' in the `:recipe':
;;(package! this-package
;;  :recipe (:host github :repo "username/repo"
;;           :files ("some-file.el" "src/lisp/*.el")))

;; If you'd like to disable a package included with Doom, you can do so here
;; with the `:disable' property:
;;(package! builtin-package :disable t)

;; You can override the recipe of a built in package without having to specify
;; all the properties for `:recipe'. These will inherit the rest of its recipe
;; from Doom or MELPA/ELPA/Emacsmirror:
;;(package! builtin-package :recipe (:nonrecursive t))
;;(package! builtin-package-2 :recipe (:repo "myfork/package"))

;; Specify a `:branch' to install a package from a particular branch or tag.
;; This is required for some packages whose default branch isn't 'master' (which
;; our package manager can't deal with; see raxod502/straight.el#279)
;;(package! builtin-package :recipe (:branch "develop"))

;; Use `:pin' to specify a particular commit to install.
;;(package! builtin-package :pin "1a2b3c4d5e")

;; Doom's packages are pinned to a specific commit and updated from release to
;; release. The `unpin!' macro allows you to unpin single packages...
;;(unpin! pinned-package)
;; ...or multiple packages
;;(unpin! pinned-package another-pinned-package)
;; ...Or *all* packages (NOT RECOMMENDED; will likely break things)
;;(unpin! t)
#+end_src
#+html: </details>

#+html: <details><summary>config.el</summary>
#+begin_src emacs-lisp :tangle config.el
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-

;; DO NOT EDIT THIS FILE DIRECTLY
;; This is a file generated from a literate programing source file located at
;; https://gitlab.com/zzamboni/dot-doom/-/blob/master/doom.org
;; You should make any changes there and regenerate it from Emacs org-mode
;; using org-babel-tangle (C-c C-v t)

;; Place your private configuration here! Remember, you do not need to run 'doom
;; sync' after modifying this file!

;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets.
;; (setq user-full-name "John Doe"
;;      user-mail-address "john@doe.com")

;; Doom exposes five (optional) variables for controlling fonts in Doom. Here
;; are the three important ones:
;;
;; + `doom-font'
;; + `doom-variable-pitch-font'
;; + `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;;
;; They all accept either a font-spec, font string ("Input Mono-12"), or xlfd
;; font string. You generally only need these two:
;; (setq doom-font (font-spec :family "monospace" :size 12 :weight 'semi-light)
;;       doom-variable-pitch-font (font-spec :family "sans" :size 13))

;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function. This is the default:
;; (setq doom-theme 'doom-one)

;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
;; (setq org-directory "~/org/")

;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
;; (setq display-line-numbers-type t)

;; Here are some additional functions/macros that could help you configure Doom:
;;
;; - `load!' for loading external *.el files relative to this one
;; - `use-package!' for configuring packages
;; - `after!' for running code after a package has loaded
;; - `add-load-path!' for adding directories to the `load-path', relative to
;;   this file. Emacs searches the `load-path' when you load packages with
;;   `require' or `use-package'.
;; - `map!' for binding new keys
;;
;; To get information about any of these functions/macros, move the cursor over
;; the highlighted symbol at press 'K' (non-evil users must press 'C-c c k').
;; This will open documentation for it, including demos of how they are used.
;;
;; You can also try 'gd' (or 'C-c c d') to jump to their definition and see how
;; they are implemented.
#+end_src
#+html: </details>

** Customized variables

Doom [[https://github.com/hlissner/doom-emacs/blob/develop/docs/getting_started.org#configure][does not recommend the Emacs =customize= mechanism]]:

#+begin_quote
/Note: do not use M-x customize or the customize API in general. Doom is designed to be configured programmatically from your config.el, which can conflict with Customize’s way of modifying variables./
#+end_quote

All necessary settings are therefore set by hand as part of this configuration file. The only exceptions are "safe variable" and "safe theme" settings, which are automatically saved by Emacs in =custom.el=, but this is OK as they don't conflict with anything else from the config.

* Doom modules

This code is written to the =init.el= to select which modules to load. Written here as-is for now, as it is quite well structured and clear.

#+begin_src emacs-lisp :tangle init.el
(doom! :input
       ;;chinese
       ;;japanese
       ;;layout            ; auie,ctsrnm is the superior home row

       :completion
       (company            ; the ultimate code completion backend
        +tng)
       ;;helm              ; the *other* search engine for love and life
       ;;ido               ; the other *other* search engine...
       (ivy                ; a search engine for love and life
        +prescient
        +fuzzy
        +icons)
       :ui
       ;;deft              ; notational velocity for Emacs
       doom                ; what makes DOOM look the way it does
       doom-dashboard      ; a nifty splash screen for Emacs
       doom-quit           ; DOOM quit-message prompts when you quit Emacs
       (emoji +unicode)  ; 🙂
       ;;fill-column         ; a `fill-column' indicator
       hl-todo             ; highlight TODO/FIXME/NOTE/DEPRECATED/HACK/REVIEW
       ;;hydra
       ;;indent-guides     ; highlighted indent columns
       (ligatures          ; ligatures and symbols to make your code pretty again
        +iosevka)
       ;;minimap           ; show a map of the code on the side
       modeline            ; snazzy, Atom-inspired modeline, plus API
       ;;nav-flash         ; blink cursor line after big motions
       ;;neotree           ; a project drawer, like NERDTree for vim
       ophints             ; highlight the region an operation acts on
       (popup +defaults)   ; tame sudden yet inevitable temporary windows
       ;;tabs              ; a tab bar for Emacs
       ;;treemacs          ; a project drawer, like neotree but cooler
       ;;unicode           ; extended unicode support for various languages
       ;;vc-gutter         ; vcs diff in the fringe
       vi-tilde-fringe     ; fringe tildes to mark beyond EOB
       ;;window-select     ; visually switch windows
       workspaces          ; tab emulation, persistence & separate workspaces
       ;;zen               ; distraction-free coding or writing

       :editor
       (evil +everywhere)  ; come to the dark side, we have cookies
       file-templates      ; auto-snippets for empty files
       fold                ; (nigh) universal code folding
       ;;(format +onsave)  ; automated prettiness
       ;;god               ; run Emacs commands without modifier keys
       ;;lispy             ; vim for lisp, for people who don't like vim
       multiple-cursors  ; editing in many places at once
       ;;objed             ; text object editing for the innocent
       ;;parinfer          ; turn lisp into python, sort of
       ;;rotate-text       ; cycle region at point between text candidates
       snippets          ; my elves. They type so I don't have to
       word-wrap         ; soft wrapping with language-aware indent

       :emacs
       (dired            ; making dired pretty [functional]
        +icons
        +ranger)
       electric          ; smarter, keyword-based electric-indent
       ;;ibuffer         ; interactive buffer management
       undo              ; persistent, smarter undo for your inevitable mistakes
       ;;vc                ; version-control and Emacs, sitting in a tree

       :term
       ;;eshell          ; the elisp shell that works everywhere
       ;;shell           ; simple shell REPL for Emacs
       ;;term            ; basic terminal emulator for Emacs
       vterm             ; the best terminal emulation in Emacs

       :checkers
       syntax            ; tasing you for every semicolon you forget
       (spell
        +flyspell
        +everywhere)     ; tasing you for misspelling mispelling
       ;;grammar         ; tasing grammar mistake every you make

       :tools
       ;;ansible
       ;;debugger          ; FIXME stepping through code, to help you add bugs
       ;;direnv
       ;;docker
       ;;editorconfig      ; let someone else argue about tabs vs spaces

       ;;ein               ; tame Jupyter notebooks with emacs
       (eval +overlay)     ; run code, run (also, repls)
       ;;gist              ; interacting with github gists
       lookup              ; navigate your code and its documentation
       lsp
       magit               ; a git porcelain for Emacs
       ;;make              ; run make tasks from Emacs
       ;;pass              ; password manager for nerds
       pdf                 ; pdf enhancements
       ;;prodigy           ; FIXME managing external services & code builders
       ;;rgb               ; creating color strings
       ;;taskrunner        ; taskrunner for all your projects
       ;;terraform         ; infrastructure as code
       tmux                ; an API for interacting with tmux
       ;;upload            ; map local to remote projects via ssh/ftp

       :os
       (:if IS-MAC macos)  ; improve compatibility with macOS
       ;;tty               ; improve the terminal Emacs experience

       :lang
       ;;agda              ; types of types of types of types...
       ;;cc                ; C/C++/Obj-C madness
       ;;clojure           ; java with a lisp
       ;;common-lisp       ; if you've seen one lisp, you've seen them all
       ;;coq               ; proofs-as-programs
       ;;crystal           ; ruby at the speed of c
       ;;csharp            ; unity, .NET, and mono shenanigans
       ;;data              ; config/data formats
       ;;(dart +flutter)   ; paint ui and not much else
       ;;elixir            ; erlang done right
       ;;elm               ; care for a cup of TEA?
       emacs-lisp          ; drown in parentheses
       ;;erlang            ; an elegant language for a more civilized age
       (ess                ; emacs speaks statistics
        +lsp)
       ;;faust             ; dsp, but you get to keep your soul
       ;;fsharp            ; ML stands for Microsoft's Language
       ;;fstar             ; (dependent) types and (monadic) effects and Z3
       ;;gdscript          ; the language you waited for
       (go +lsp)           ; the hipster dialect
       ;;(haskell +dante)  ; a language that's lazier than I am
       ;;hy                ; readability of scheme w/ speed of python
       ;;idris             ; a language you can depend on
       json                ; At least it ain't XML
       ;;(java +meghanada) ; the poster child for carpal tunnel syndrome
       javascript          ; all(hope(abandon(ye(who(enter(here))))))
       (julia              ; a better, faster MATLAB
        +lsp)
       ;;kotlin            ; a better, slicker Java(Script)
       latex               ; writing papers in Emacs has never been so fun
       ;;lean
       ;;factor
       ;;ledger            ; an accounting system in Emacs
       ;;lua               ; one-based indices? one-based indices
       markdown            ; writing docs for people to ignore
       ;;nim               ; python + lisp at the speed of c
       ;;nix               ; I hereby declare "nix geht mehr!"
       ;;ocaml             ; an objective camel
       (org                ; organize your plain life in plain text
        +brain
        +dragndrop
        +hugo
        +journal
        +jupyter
        +noter
        +pandoc
        +present
        +pretty
        +roam)
       ;;php               ; perl's insecure younger brother
       ;;plantuml          ; diagrams for confusing people more
       ;;purescript        ; javascript, but functional
       (python             ; beautiful is better than ugly
        +lsp
        +pyright
        +pyenv
        +poetry
        +cython)
       ;;qt                ; the 'cutest' gui framework ever
       ;;racket            ; a DSL for DSLs
       ;;raku              ; the artist formerly known as perl6
       ;;rest              ; Emacs as a REST client
       ;;rst               ; ReST in peace
       ;;(ruby +rails)     ; 1.step {|i| p "Ruby is #{i.even? ? 'love' : 'life'}"}
       ;;rust              ; Fe2O3.unwrap().unwrap().unwrap().unwrap()
       ;;scala             ; java, but good
       ;;scheme            ; a fully conniving family of lisps
       sh                  ; she sells {ba,z,fi}sh shells on the C xor
       ;;sml
       ;;solidity          ; do you need a blockchain? No.
       ;;swift             ; who asked for emoji variables?
       ;;terra             ; Earth and Moon in alignment for performance.
       ;;web               ; the tubes
       ;;yaml              ; JSON, but readable

       :email
       ;;(mu4e +gmail)
       ;;notmuch
       (wanderlust +gmail)

       :app
       ;;calendar
       ;;everywhere        ; *leave* Emacs!? You must be joking
       ;;irc               ; how neckbeards socialize
       ;;(rss +org)        ; emacs as an RSS reader
       ;;twitter           ; twitter client https://twitter.com/vnought

       :config
       ;;literate
       (default +bindings +smartparens))
#+end_src

* General configuration

My user information.

#+begin_src emacs-lisp
(setq user-full-name "Giuseppe Ragusa"
      user-mail-address "giuseppe.ragusa@gmail.com")
#+end_src

I am very much used to have the usual MAC keybindings. They are bounded in Carbon Emacs. I am using Emacs@28, so I need to manually add them. This can be done quite easily by the [[http://svn.sourceforge.jp/cgi-bin/viewcvs.cgi/zenitani/CarbonEmacs/src/lisp/mac-key-mode.el?root=macwiki&view=markup][mac-key-mode]].
#+begin_src emacs-lisp :tangle packages.el
(cond (IS-MAC
(package! mac-key-mode)
))
#+end_src

This is disabled.
#+begin_src emacs-lisp :tangle no
(cond (IS-MAC
       (setq mac-command-modifier      'meta
             mac-option-modifier       'alt
             mac-right-option-modifier 'alt)))
#+end_src

When at the beginning of the line, make =Ctrl-K= remove the whole line, instead of just emptying it.
#+begin_src emacs-lisp
(setq kill-whole-line t)
#+end_src


For some reason Doom disables auto-save and backup files by default. Let's reenable them.

#+begin_src emacs-lisp
(setq auto-save-default t
      make-backup-files t)
#+end_src

Disable exit confirmation.

#+begin_src emacs-lisp
(setq confirm-kill-emacs nil)
#+end_src

** Keybindings

I have used emacs for a long time on different platforms and i am used to several keybinding that I should probably forget, but muscle memory gets me everytime.

#+begin_src emacs-lisp
(when (eq system-type 'darwin)
  (global-set-key [(M-s-right)] 'windmove-right)
  (global-set-key [(M-s-left)] 'windmove-left)
  (global-set-key [(M-s-up)] 'windmove-up)
  (global-set-key [(M-s-down)] 'windmove-down)
  (map! :ne "s-/" #'comment-or-uncomment-region)
  )

(when (eq system-type 'gnu/linux)
  (global-set-key [(M-s-right)] 'windmove-right)
  (global-set-key [(M-s-left)] 'windmove-left)
  (global-set-key [(M-s-up)] 'windmove-up)
  (global-set-key [(M-s-down)] 'windmove-down)
  (map! :nei "s-x" #'execute-extended-command)
  (map! :nei "M-/" #'comment-or-uncomment-region)
  (map! :nei "s-/" #'comment-or-uncomment-region)
  (map! :nei "s-c" #'kill-ring-save)
  (map! :nei "s-v" #'yank)
  (map! :nei "s-z" #'undo-fu-only-undo)
  (map! :nei "S-z" #'undo-fu-only-redo)
  (map! :nei "s-s" #'save-buffer)
)

(global-set-key [f1] 'replace-string)
(global-set-key [f2] 'split-window-horizontally)
(global-set-key [f3] 'split-window-vertically)
(global-set-key [f4] 'delete-window)
(global-set-key [home] 'beginning-of-line)
(global-set-key [end] 'end-of-line)
#+end_src

** Visual, session and window settings

I made a super simple set of Doom-Emacs custom splash screens by combining [[http://www.thedreamcastjunkyard.co.uk/2018/03/cross-platform-online-multiplayer-added.html][a Doom logo]] with the word "Emacs" rendered in the [[https://fontmeme.com/doom-font/][Doom Font]]. You can see them at https://gitlab.com/zzamboni/dot-doom/-/tree/master/splash (you can also see one of them at the top of this file). I configure it to be used instead of the default splash screen. It took me all of 5 minutes to make, so improvements are welcome!

If you want to choose at random among a few different splash images, you can list them in =alternatives=.

#+begin_src emacs-lisp
(let ((alternatives '("doom-emacs-bw-light.svg")))
   ;;((alternatives '("doom-emacs-color.png" "doom-emacs-bw-light.svg")))
  (setq fancy-splash-image
        (concat doom-private-dir "splash/"
                (nth (random (length alternatives)) alternatives))))
#+end_src

Set base and variable-pitch fonts. I currently like [[https://github.com/be5invis/Iosevka]Iosevka SS4]] and [[https://www.huertatipografica.com/en/fonts/alegreya-ht-pro][Alegreya]]. I also use a laptop (OSX) where a prefer smaller font sizes and a desktop (Linux) so a set font size conditionally.

#+begin_src emacs-lisp
(cond (IS-MAC
       (setq doom-font (font-spec :family "Iosevka SS04" :size 18)
)))

 (cond (IS-LINUX
       (setq doom-font (font-spec :family "Iosevka SS04" :size 22)
             )))
#+end_src

Allow mixed fonts in a buffer. This is particularly useful for Org mode, so I can mix source and prose blocks in the same document.

#+begin_src emacs-lisp :tangle no
(add-hook! org-mode-hook #'mixed-pitch-mode)
(setq mixed-pitch-variable-pitch-cursor nil)
#+end_src

Set the theme to use.
#+begin_src emacs-lisp
;;(setq doom-theme 'doom-nord-light)
;;(setq doom-theme 'doom-solarized-light)
#+end_src

In my previous configuration, I used to automatically restore the previous session upon startup. Doom Emacs starts up so fast that it does not feel right to do it automatically. In any case, from the Doom dashboard I can simply press Enter to invoke the first item, which is "Reload Last Session". So this code is commented out now.

#+begin_src emacs-lisp
;;(add-hook 'window-setup-hook #'doom/quickload-session)
#+end_src

Maximize the window upon startup.

#+begin_src emacs-lisp
(add-to-list 'initial-frame-alist '(fullscreen . maximized))
#+end_src

Truncate lines in =ivy= childframes. [[https://discord.com/channels/406534637242810369/484105925733646336/770756709857755187][Thanks Henrik]]! (disabled for now)

#+begin_src emacs-lisp :tangle no
(setq posframe-arghandler
      (lambda (buffer-or-name key value)
        (or (and (eq key :lines-truncate)
                 (equal ivy-posframe-buffer
                        (if (stringp buffer-or-name)
                            buffer-or-name
                          (buffer-name buffer-or-name)))
                 t)
            value)))
#+end_src
** Key bindings

Doom Emacs has an extensive keybinding system, and most module functions are already bound. I modify some keybindings for simplicity of to match the muscle memory I have from my previous Emacs configuration.

*Note:* I do not use VI-style keybindings (which are the default for Doom) because I have decades of muscle memory with Emacs-style keybindings. You may need to adjust these if you want to use them.

*** Miscellaneous keybindings

Use =counsel-buffer-or-recentf= for ~C-x b~. I like being able to see all recently opened files, instead of just the current ones. This makes it possible to use ~C-x b~ almost as a replacement for ~C-c C-f~, for files that I edit often. Similarly, for switching between non-file buffers I use =counsel-switch-buffer=, mapped to ~C-x C-b~.

#+begin_src emacs-lisp
(map! "C-x b"   #'counsel-buffer-or-recentf
      "C-x C-b" #'counsel-switch-buffer)
#+end_src

The =counsel-buffer-or-recentf= function by default shows duplicated entries because it does not abbreviate the paths of the open buffers. The function below fixes this, I have submitted this change to the =counsel= library (https://github.com/abo-abo/swiper/pull/2687), in the meantime I define it here and integrate it via =advice-add=.

#+begin_src emacs-lisp
(defun zz/counsel-buffer-or-recentf-candidates ()
  "Return candidates for `counsel-buffer-or-recentf'."
  (require 'recentf)
  (recentf-mode)
  (let ((buffers
         (delq nil
               (mapcar (lambda (b)
                         (when (buffer-file-name b)
                           (abbreviate-file-name (buffer-file-name b))))
                       (delq (current-buffer) (buffer-list))))))
    (append
     buffers
     (cl-remove-if (lambda (f) (member f buffers))
                   (counsel-recentf-candidates)))))

(advice-add #'counsel-buffer-or-recentf-candidates
            :override #'zz/counsel-buffer-or-recentf-candidates)
#+end_src

The =switch-buffer-functions= package allows us to update the =recentf= buffer list as we switch between them, so that the list produced by =counsel-buffer-or-recentf= is shown in the order the buffers have been visited, rather than in the order they were opened. Thanks to [[https://github.com/abo-abo/swiper/issues/1560#issuecomment-729403768][@tau3000]] for the tip.

#+begin_src emacs-lisp :tangle packages.el
(package! switch-buffer-functions)
#+end_src

#+begin_src emacs-lisp
(use-package! switch-buffer-functions
  :after recentf
  :preface
  (defun my-recentf-track-visited-file (_prev _curr)
    (and buffer-file-name
         (recentf-add-file buffer-file-name)))
  :init
  (add-hook 'switch-buffer-functions #'my-recentf-track-visited-file))
#+end_src

The following will use =+default/search-buffer= for searching by default, but I don't like the Swiper interface so I disable it.

#+begin_src emacs-lisp :tangle no
;;(map! "C-s" #'counsel-grep-or-swiper)
(map! "C-s" #'+default/search-buffer)
#+end_src

Map ~C-c C-g~ to =magit-status=

#+begin_src emacs-lisp
(map! :after magit "C-c C-g" #'magit-status)
#+end_src

Interactive search key bindings -  [[https://github.com/benma/visual-regexp-steroids.el][visual-regexp-steroids]] provides sane regular expressions and visual incremental search. I use the =pcre2el= package to support PCRE-style regular expressions.

#+begin_src emacs-lisp :tangle packages.el
(package! pcre2el)
(package! visual-regexp-steroids)
#+end_src

#+begin_src emacs-lisp
(use-package! visual-regexp-steroids
  :defer 3
  :config
  (require 'pcre2el)
  (setq vr/engine 'pcre2el)
  (map! "C-c s r" #'vr/replace)
  (map! "C-c s q" #'vr/query-replace))
#+end_src

The Doom =undo= package introduces the use of [[https://gitlab.com/ideasman42/emacs-undo-fu][=undo-fu=]], which makes undo/redo more "lineal". I normally use ~C-/~ for undo and Emacs doesn't have a separate "redo" action, so I map ~C-?~ (in my keyboard, the same combination + ~Shift~) for redo.

#+begin_src emacs-lisp
(after! undo-fu
  (map! :map undo-fu-mode-map "C-?" #'undo-fu-only-redo))
#+end_src

Replace the default =goto-line= keybindings with =avy-goto-line=, which is more flexible and also falls back to =goto-line= if a number is typed.

#+begin_src emacs-lisp
(map! "M-g g" #'avy-goto-line)
(map! "M-g M-g" #'avy-goto-line)
#+end_src

Map a keybindings for =counsel-outline=, which allows easily navigating documents (it works best with Org documents, but it also tries to extract navigation information from other file types).

#+begin_src emacs-lisp
(map! "M-g o" #'counsel-outline)
#+end_src

*** Emulating vi's =%= key

One of the few things I missed in Emacs from vi was the =%= key, which jumps to the parenthesis, bracket or brace which matches the one below the cursor. This function implements this functionality, bound to the same key. Inspired by [[http://www.emacswiki.org/emacs/NavigatingParentheses][NavigatingParentheses]], but modified to use =smartparens= instead of the default commands, and to work on brackets and braces.

#+begin_src emacs-lisp
(after! smartparens
  (defun zz/goto-match-paren (arg)
    "Go to the matching paren/bracket, otherwise (or if ARG is not
    nil) insert %.  vi style of % jumping to matching brace."
    (interactive "p")
    (if (not (memq last-command '(set-mark
                                  cua-set-mark
                                  zz/goto-match-paren
                                  down-list
                                  up-list
                                  end-of-defun
                                  beginning-of-defun
                                  backward-sexp
                                  forward-sexp
                                  backward-up-list
                                  forward-paragraph
                                  backward-paragraph
                                  end-of-buffer
                                  beginning-of-buffer
                                  backward-word
                                  forward-word
                                  mwheel-scroll
                                  backward-word
                                  forward-word
                                  mouse-start-secondary
                                  mouse-yank-secondary
                                  mouse-secondary-save-then-kill
                                  move-end-of-line
                                  move-beginning-of-line
                                  backward-char
                                  forward-char
                                  scroll-up
                                  scroll-down
                                  scroll-left
                                  scroll-right
                                  mouse-set-point
                                  next-buffer
                                  previous-buffer
                                  previous-line
                                  next-line
                                  back-to-indentation
                                  doom/backward-to-bol-or-indent
                                  doom/forward-to-last-non-comment-or-eol
                                  )))
        (self-insert-command (or arg 1))
      (cond ((looking-at "\\s\(") (sp-forward-sexp) (backward-char 1))
            ((looking-at "\\s\)") (forward-char 1) (sp-backward-sexp))
            (t (self-insert-command (or arg 1))))))
  (map! "%" 'zz/goto-match-paren))
#+end_src

* Org mode

[[http://orgmode.org/][Org mode]] has become my primary tool for writing, blogging, coding, presentations and more. I am duly impressed. I have been a fan of the idea of [[https://en.wikipedia.org/wiki/Literate_programming][literate programming]] for many years, and I have tried other tools before (most notably [[https://www.cs.tufts.edu/~nr/noweb/][noweb]], which I used during grad school for homeworks and projects), but Org is the first tool I have encountered which makes it practical. Here are some of the resources I have found useful in learning it:

- Howard Abrams' [[http://www.howardism.org/Technical/Emacs/literate-programming-tutorial.html][Introduction to Literate Programming]], which got me jumpstarted into writing code documented with org-mode.
- Nick Anderson's [[https://github.com/nickanderson/Level-up-your-notes-with-Org][Level up your notes with Org]], which contains many useful tips and configuration tricks. Nick's recommendation also got me to start looking into Org-mode in the first place!
- Sacha Chua's [[http://sachachua.com/blog/2014/01/tips-learning-org-mode-emacs/][Some tips for learning Org Mode for Emacs]], her [[http://pages.sachachua.com/.emacs.d/Sacha.html][Emacs configuration]] and many of her [[http://sachachua.com/blog/category/emacs/][other articles]].
- Rainer König's [[https://www.youtube.com/playlist?list=PLVtKhBrRV_ZkPnBtt_TD1Cs9PJlU0IIdE][OrgMode Tutorial]] video series.

Doom's Org module provides a lot of sane configuration settings, so I don't have to configure so much as in my [[https://github.com/zzamboni/dot-emacs/][previous hand-crafted config]].

** General Org Configuration

Default directory for Org files. I keep everything in Dropbox.
#+begin_src emacs-lisp
(setq org-directory "~/Dropbox/Org/")
#+end_src

Hide Org markup indicators.
#+begin_src emacs-lisp
(after! org (setq org-hide-emphasis-markers t))
#+end_src

Insert Org headings at point, not after the current subtree (this is enabled by default by Doom).

#+begin_src emacs-lisp
(after! org (setq org-insert-heading-respect-content nil))
#+end_src

Enable logging of done tasks, and log stuff into the LOGBOOK drawer by default
#+begin_src emacs-lisp
(after! org
  (setq org-log-done t)
  (setq org-log-into-drawer t))
#+end_src

Use the special ~C-a~, ~C-e~ and ~C-k~ definitions for Org, which enable some special behavior in headings.

#+begin_src emacs-lisp
(after! org
  (setq org-special-ctrl-a/e t)
  (setq org-special-ctrl-k t))
#+end_src

Enable [[https://orgmode.org/manual/Speed-keys.html][Speed Keys]], which allows quick single-key commands when the cursor is placed on a heading. Usually the cursor needs to be at the beginning of a headline line, but defining it with this function makes them active on any of the asterisks at the beginning of the line.

#+begin_src emacs-lisp
(after! org
  (setq org-use-speed-commands
        (lambda ()
          (and (looking-at org-outline-regexp)
               (looking-back "^\**")))))
#+end_src

Disable [[https://code.orgmode.org/bzg/org-mode/src/master/etc/ORG-NEWS#L323][electric-mode]], which is now respected by Org and which creates some confusing indentation sometimes.

#+begin_src emacs-lisp
(add-hook! org-mode (electric-indent-local-mode -1))
#+end_src

I dislike completion of words as I type prose (in code it's OK), so I disable it in Org:

#+begin_src emacs-lisp
(defun zz/adjust-org-company-backends ()
  (remove-hook 'after-change-major-mode-hook '+company-init-backends-h)
  (setq-local company-backends nil))
(add-hook! org-mode (zz/adjust-org-company-backends))
#+end_src
** Org visual settings

Enable variable and visual line mode in Org mode by default and start intend mode.

#+begin_src emacs-lisp
(add-hook! org-mode :append
           #'visual-line-mode
           #'org-indent-mode
           #'prettify-symbol-mode)
#+end_src

Nicer bullets, but with some twist by the new [[https://github.com/integral-dw/org-superstar-mode][org-superstar-mode]]

#+begin_src emacs-lisp :tangle packages.el
(package! org-superstar)
#+end_src


Use [[https://github.com/awth13/org-appear][org-appear]] to reveal emphasis markers when moving the cursor over them.

#+begin_src emacs-lisp :tangle packages.el
(package! org-appear
  :recipe (:host github
           :repo "awth13/org-appear"))
#+end_src
#+begin_src emacs-lisp
(add-hook! org-mode :append #'org-appear-mode)
#+end_src

I want tab to behave natively when inside src block
#+begin_src emacs-lisp
(setq org-src-tab-acts-natively t)
#+end_src

This substitute =#+begin_src= with nicer unicode fonts
#+begin_src emacs-lisp
(setq-default prettify-symbols-alist '(("#+BEGIN_SRC" . "⋖")
                                       ("#+END_SRC" . "⋗")
                                       ("#+begin_src" . "⋖")
                                       ("#+end_src" . "⋗")))
                                       ;; (">=" . "≥")
                                       ;; ("=>" . "⇨")))
(setq prettify-symbols-unprettify-at-point 'right-edge)

#+end_src

** Latex exporter
If I export code to latex using minted, I have to invoke latex with =--shell-escape=. The following also setup a foil class. TODO: I should make this prettier.
#+begin_src emacs-lisp
(add-hook 'org-mode-hook
          (lambda()
            (org-bullets-mode 1)
            (add-to-list 'org-latex-packages-alist '("" "minted"))
            (setq org-export-allow-bind-keywords t
                  org-latex-listings 'minted)
            (setq org-latex-pdf-process
                  '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
                    "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
                    "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
            (add-to-list 'org-latex-classes
                         '("foils"
                           "\\documentclass{foils}"
                           ("\\foilhead[-1cm]{%s}" . "\\foilhead[-1cm]*(%s)"))
                         )
            (setq org-latex-minted-options
                  '(("fontsize" "\\scriptsize")
                    ("obeytabs" "true")
                    ("bgcolor" "gray!10")
                    ("frame" "none")
                    ("linenos" "true")
                    ("mathescape" "true")
                    ))
   ))
#+end_src
** Capturing and note taking

First, I define where all my Org-captured things can be found.

#+begin_src emacs-lisp
(after! org
  (setq org-agenda-files
        '("~/Dropbox/Org/")))
#+end_src

I define some global keybindings  to open my frequently-used org files (original tip from [[https://sachachua.com/blog/2015/02/learn-take-notes-efficiently-org-mode/][Learn how to take notes more efficiently in Org Mode]]).

First, I define a helper function to define keybindings that open files. Note that this requires lexical binding to be enabled, so that  the =lambda= creates a closure, otherwise the keybindings don't work.

#+begin_src emacs-lisp
(defun zz/add-file-keybinding (key file &optional desc)
  (let ((key key)
        (file file)
        (desc desc))
    (map! :desc (or desc file)
          key
          (lambda () (interactive) (find-file file)))))
#+end_src

Now I define keybindings to access my commonly-used org files.

#+begin_src emacs-lisp
(zz/add-file-keybinding "C-c z i" "~/org/ideas.org" "ideas.org")
(zz/add-file-keybinding "C-c z p" "~/org/projects.org" "projects.org")
(zz/add-file-keybinding "C-c z d" "~/org/diary.org" "diary.org")
#+end_src

I'm still trying out =org-roam=, although I have not figured out very well how it works for my setup. For now I configure it to include my whole Org directory.

#+begin_src emacs-lisp
(setq org-roam-directory org-directory)
(setq +org-roam-open-buffer-on-find-file t)
#+end_src

** Capturing images

Using =org-download= to make it easier to insert images into my org notes. I don't like the configuration provided by Doom as part of the =(org +dragndrop)= module, so I install the package by hand and configure it to my liking. I also define a new keybinding to paste an image from the clipboard, asking for the filename first.

#+begin_src emacs-lisp :tangle packages.el
(package! org-download)
#+end_src
#+begin_src emacs-lisp
(defun zz/org-download-paste-clipboard (&optional use-default-filename)
  (interactive "P")
  (require 'org-download)
  (let ((file
         (if (not use-default-filename)
             (read-string (format "Filename [%s]: "
                                  org-download-screenshot-basename)
                          nil nil org-download-screenshot-basename)
           nil)))
    (org-download-clipboard file)))

(after! org
  (setq org-download-method 'directory)
  (setq org-download-image-dir "images")
  (setq org-download-heading-lvl nil)
  (setq org-download-timestamp "%Y%m%d-%H%M%S_")
  (setq org-image-actual-width 300)
  (map! :map org-mode-map
        "C-c l a y" #'zz/org-download-paste-clipboard
        "C-M-y" #'zz/org-download-paste-clipboard))
#+end_src

** Capturing links

*** Capturing and creating internal Org links

I normally use =counsel-org-link= for linking between headings in an Org document. It shows me a searchable list of all the headings in the current document, and allows selecting one, automatically creating a link to it. Since it doesn't have a keybinding by default, I give it one.

#+begin_src emacs-lisp
(map! :after counsel :map org-mode-map
      "C-c l l h" #'counsel-org-link)
#+end_src

I also configure =counsel-outline-display-style= so that only the headline title is inserted into the link, instead of its full path within the document.

#+begin_src emacs-lisp
(after! counsel
  (setq counsel-outline-display-style 'title))
#+end_src

=counsel-org-link= uses =org-id= as its backend which generates IDs using UUIDs, and it uses the =ID= property to store them. I prefer using human-readable IDs stored in the =CUSTOM_ID= property of each heading, so we need to make some changes.

First, configure =org-id= to use =CUSTOM_ID= if it exists. This affects the links generated by the =org-store-link= function.

#+begin_src emacs-lisp
(after! org-id
  ;; Do not create ID if a CUSTOM_ID exists
  (setq org-id-link-to-org-use-id 'create-if-interactive-and-no-custom-id))
#+end_src

Second, I override =counsel-org-link-action=, which is the function that actually generates and inserts the link, with a custom function that computes and inserts human-readable =CUSTOM_ID= links. This is supported by a few auxiliary functions for generating and storing the =CUSTOM_ID=.

#+begin_src emacs-lisp
(defun zz/make-id-for-title (title)
  "Return an ID based on TITLE."
  (let* ((new-id (replace-regexp-in-string "[^[:alnum:]]" "-" (downcase title))))
    new-id))

(defun zz/org-custom-id-create ()
  "Create and store CUSTOM_ID for current heading."
  (let* ((title (or (nth 4 (org-heading-components)) ""))
         (new-id (zz/make-id-for-title title)))
    (org-entry-put nil "CUSTOM_ID" new-id)
    (org-id-add-location new-id (buffer-file-name (buffer-base-buffer)))
    new-id))

(defun zz/org-custom-id-get-create (&optional where force)
  "Get or create CUSTOM_ID for heading at WHERE.

If FORCE is t, always recreate the property."
  (org-with-point-at where
    (let ((old-id (org-entry-get nil "CUSTOM_ID")))
      ;; If CUSTOM_ID exists and FORCE is false, return it
      (if (and (not force) old-id (stringp old-id))
          old-id
        ;; otherwise, create it
        (zz/org-custom-id-create)))))

;; Now override counsel-org-link-action
(after! counsel
  (defun counsel-org-link-action (x)
    "Insert a link to X.

X is expected to be a cons of the form (title . point), as passed
by `counsel-org-link'.

If X does not have a CUSTOM_ID, create it based on the headline
title."
    (let* ((id (zz/org-custom-id-get-create (cdr x))))
      (org-insert-link nil (concat "#" id) (car x)))))
#+end_src

Ta-da! Now using =counsel-org-link= inserts nice, human-readable links.

*** Capturing links to external applications

=org-mac-link= implements the ability to grab links from different Mac apps and insert them in the file. Bind =C-c g= to call =org-mac-grab-link= to choose an application and insert a link.

#+begin_src emacs-lisp
(when IS-MAC
  (use-package! org-mac-link
    :after org
    :config
    (setq org-mac-grab-Acrobat-app-p nil) ; Disable grabbing from Adobe Acrobat
    (setq org-mac-grab-devonthink-app-p nil) ; Disable grabbinb from DevonThink
    (map! :map org-mode-map
          "C-c g"  #'org-mac-grab-link)))
#+end_src

** Tasks and agenda

Customize the agenda display to indent todo items by level to show nesting, and enable showing holidays in the Org agenda display.

#+begin_src emacs-lisp
(after! org-agenda
  (setq org-agenda-prefix-format
        '((agenda . " %i %-12:c%?-12t% s")
          ;; Indent todo items by level to show nesting
          (todo . " %i %-12:c%l")
          (tags . " %i %-12:c")
          (search . " %i %-12:c")))
  (setq org-agenda-include-diary t))
#+end_src


[[https://github.com/alphapapa/org-super-agenda][org-super-agenda]] provides great grouping and customization features to make agenda mode easier to use.

#+begin_src emacs-lisp :tangle packages.el
(package! org-super-agenda)
#+end_src
#+begin_src emacs-lisp
(use-package! org-super-agenda
  :after org-agenda
  :config
  (setq org-super-agenda-groups '((:auto-dir-name t)))
  (org-super-agenda-mode))
#+end_src

I configure =org-archive= to archive completed TODOs by default to the =archive.org= file in the same directory as the source file, under the "date tree" corresponding to the task's CLOSED date - this allows me to easily separate work from non-work stuff. Note that this can be overridden for specific files by specifying the desired value of =org-archive-location= in the =#+archive:= property at the top of the file.

#+begin_src emacs-lisp
(use-package! org-archive
  :after org
  :config
  (setq org-archive-location "archive.org::datetree/"))
#+end_src

I have started using =org-clock= to track time I spend on tasks. Often I restart Emacs for different reasons in the middle of a session, so I want to persist all the running clocks and their history.

#+begin_src emacs-lisp
(after! org-clock
  (setq org-clock-persist t)
  (org-clock-persistence-insinuate))
#+end_src

** GTD

I am trying out Trevoke's [[https://github.com/Trevoke/org-gtd.el][org-gtd]]. I haven't figured out my perfect workflow for tracking GTD with Org yet, but this looks like a very promising approach.

#+begin_src emacs-lisp :tangle packages.el
(package! org-gtd)
#+end_src
#+begin_src emacs-lisp
(use-package! org-gtd
  :after org
  :config
  ;; where org-gtd will put its files. This value is also the default one.
  (setq org-gtd-directory "~/gtd/")
  ;; package: https://github.com/Malabarba/org-agenda-property
  ;; this is so you can see who an item was delegated to in the agenda
  (setq org-agenda-property-list '("DELEGATED_TO"))
  ;; I think this makes the agenda easier to read
  (setq org-agenda-property-position 'next-line)
  ;; package: https://www.nongnu.org/org-edna-el/
  ;; org-edna is used to make sure that when a project task gets DONE,
  ;; the next TODO is automatically changed to NEXT.
  (setq org-edna-use-inheritance t)
  (org-edna-load)
  :bind
  (("C-c d c" . org-gtd-capture) ;; add item to inbox
   ("C-c d a" . org-agenda-list) ;; see what's on your plate today
   ("C-c d p" . org-gtd-process-inbox) ;; process entire inbox
   ("C-c d n" . org-gtd-show-all-next) ;; see all NEXT items
   ;; see projects that don't have a NEXT item
   ("C-c d s" . org-gtd-show-stuck-projects)
   ;; the keybinding to hit when you're done editing an item in the
   ;; processing phase
   ("C-c d f" . org-gtd-clarify-finalize)))
#+end_src

*** Capture templates

We define the corresponding Org-GTD capture templates.

#+begin_src emacs-lisp
(after! (org-gtd org-capture)
  (add-to-list 'org-capture-templates
               '("i" "GTD item"
                 entry
                 (file (lambda () (org-gtd--path org-gtd-inbox-file-basename)))
                 "* %?\n%U\n\n  %i"
                 :kill-buffer t))
  (add-to-list 'org-capture-templates
               '("l" "GTD item with link to where you are in emacs now"
                 entry
                 (file (lambda () (org-gtd--path org-gtd-inbox-file-basename)))
                 "* %?\n%U\n\n  %i\n  %a"
                 :kill-buffer t))
  (add-to-list 'org-capture-templates
               '("m" "GTD item with link to current Outlook mail message"
                 entry
                 (file (lambda () (org-gtd--path org-gtd-inbox-file-basename)))
                 "* %?\n%U\n\n  %i\n  %(org-mac-outlook-message-get-links)"
                 :kill-buffer t)))
#+end_src

I set up an advice before =org-capture= to make sure =org-gtd= and =org-capture= are loaded, which triggers the setup of the templates above.

#+begin_src emacs-lisp
(defadvice! +zz/load-org-gtd-before-capture (&optional goto keys)
    :before #'org-capture
    (require 'org-capture)
    (require 'org-gtd))
#+end_src
** Exporting a Curriculum Vitae

I use =ox-awesomecv= from [[https://titan-c.gitlab.io/org-cv/][Org-CV]], to export my [[https://github.com/zzamboni/vita/][Curriculum Vit\aelig]].

My =ox-awesomecv= package is [[https://gitlab.com/Titan-C/org-cv/-/merge_requests/3][not yet merged]] into the main Org-CV distribution, so I install from my branch for now.

#+begin_src emacs-lisp :tangle packages.el
(package! org-cv
  :recipe (:host gitlab :repo "zzamboni/org-cv" :branch "awesomecv"))
#+end_src
#+begin_src emacs-lisp
(use-package! ox-awesomecv
  :after org)
(use-package! ox-moderncv
  :after org)
#+end_src

** Blogging with Hugo

[[https://ox-hugo.scripter.co/][ox-hugo]] is an awesome way to blog from org-mode. It makes it possible for posts in org-mode format to be kept separate, and it generates the Markdown files for Hugo. Hugo [[https://gohugo.io/content-management/formats/][supports org files]], but using ox-hugo has multiple advantages:

- Parsing is done by org-mode natively, not by an external library. Although goorgeous (used by Hugo) is very good, it still lacks in many areas, which leads to text being interpreted differently as by org-mode.
- Hugo is left to parse a native Markdown file, which means that many of its features such as shortcodes, TOC generation, etc., can still be used on the generated file.

Doom Emacs includes and configures =ox-hugo= as part of its =(:lang org +hugo)= module, so all that's left is to configure some parameters to my liking.

I set =org-hugo-use-code-for-kbd= so that I can apply a custom style to keyboard bindings in my blog.

#+begin_src emacs-lisp
(after! ox-hugo
  (setq org-hugo-use-code-for-kbd t))
#+end_src
** Code for org-mode macros

Here I define functions which get used in some of my org-mode macros

The first is a support function which gets used in some of the following, to return a string (or an optional custom  string) only if  it  is a non-zero, non-whitespace string,  and =nil= otherwise.

#+begin_src emacs-lisp
(defun zz/org-if-str (str &optional desc)
  (when (org-string-nw-p str)
    (or (org-string-nw-p desc) str)))
#+end_src

This function receives three arguments, and returns the org-mode code for a link to the Hammerspoon API documentation for the =link= module, optionally to a specific =function=. If =desc= is passed, it is used as the display text, otherwise =section.function= is used.

#+begin_src emacs-lisp
(defun zz/org-macro-hsapi-code (module &optional func desc)
  (org-link-make-string
   (concat "https://www.hammerspoon.org/docs/"
           (concat module (zz/org-if-str func (concat "#" func))))
   (or (org-string-nw-p desc)
       (format "=%s="
               (concat module
                       (zz/org-if-str func (concat "." func)))))))
#+end_src

Split STR at spaces and wrap each element with the =~= char, separated by =+=. Zero-width spaces are inserted around the plus signs so that they get formatted correctly. Envisioned use is for formatting keybinding descriptions. There are two versions of this function: "outer" wraps each element in  =~=, the "inner" wraps the whole sequence in them.

#+begin_src emacs-lisp
(defun zz/org-macro-keys-code-outer (str)
  (mapconcat (lambda (s)
               (concat "~" s "~"))
             (split-string str)
             (concat (string ?\u200B) "+" (string ?\u200B))))
(defun zz/org-macro-keys-code-inner (str)
  (concat "~" (mapconcat (lambda (s)
                           (concat s))
                         (split-string str)
                         (concat (string ?\u200B) "-" (string ?\u200B)))
          "~"))
(defun zz/org-macro-keys-code (str)
  (zz/org-macro-keys-code-inner str))
#+end_src

Links to a specific section/function of the Lua manual.

#+begin_src emacs-lisp
(defun zz/org-macro-luadoc-code (func &optional section desc)
  (org-link-make-string
   (concat "https://www.lua.org/manual/5.3/manual.html#"
           (zz/org-if-str func section))
   (zz/org-if-str func desc)))
#+end_src

#+begin_src emacs-lisp
(defun zz/org-macro-luafun-code (func &optional desc)
  (org-link-make-string
   (concat "https://www.lua.org/manual/5.3/manual.html#"
           (concat "pdf-" func))
   (zz/org-if-str (concat "=" func "()=") desc)))
#+end_src
** Reformatting an Org buffer

I picked up this little gem in the org mailing list. A function that reformats the current buffer by regenerating the text from its internal parsed representation. Quite amazing.

#+begin_src emacs-lisp
(defun zz/org-reformat-buffer ()
  (interactive)
  (when (y-or-n-p "Really format current buffer? ")
    (let ((document (org-element-interpret-data (org-element-parse-buffer))))
      (erase-buffer)
      (insert document)
      (goto-char (point-min)))))
#+end_src

** Avoiding non-Org mode files

[[https://github.com/tecosaur/org-pandoc-import][org-pandoc-import]] is a mode that automates conversions to/from Org mode as much as possible.

#+begin_src emacs-lisp :tangle packages.el
(package! org-pandoc-import
  :recipe (:host github
           :repo "tecosaur/org-pandoc-import"
           :files ("*.el" "filters" "preprocessors")))
#+end_src

#+begin_src emacs-lisp
(use-package org-pandoc-import)
#+end_src

** Reveal.js presentations

I use =org-re-reveal= to make presentations. The functions below help me improve my workflow by automatically exporting the slides whenever I save the file, refreshing the presentation in my browser, and moving it to the slide where the cursor was when I saved the file. This helps keeping a "live" rendering of the presentation next to my Emacs window.

The first function is a modified version of the =org-num--number-region= function of the =org-num= package, but modified to only return the numbering of the innermost headline in which the cursor is currently placed.

#+begin_src emacs-lisp
(defun zz/org-current-headline-number ()
  "Get the numbering of the innermost headline which contains the
cursor. Returns nil if the cursor is above the first level-1
headline, or at the very end of the file. Does not count
headlines tagged with :noexport:"
  (require 'org-num)
  (let ((org-num--numbering nil)
        (original-point (point)))
    (save-mark-and-excursion
      (let ((new nil))
        (org-map-entries
         (lambda ()
           (when (org-at-heading-p)
             (let* ((level (nth 1 (org-heading-components)))
                    (numbering (org-num--current-numbering level nil)))
               (let* ((current-subtree (save-excursion (org-element-at-point)))
                      (point-in-subtree
                       (<= (org-element-property :begin current-subtree)
                           original-point
                           (1- (org-element-property :end current-subtree)))))
                 ;; Get numbering to current headline if the cursor is in it.
                 (when point-in-subtree (push numbering
                                              new))))))
         "-noexport")
        ;; New contains all the trees that contain the cursor (i.e. the
        ;; innermost and all its parents), so we only return the innermost one.
        ;; We reverse its order to make it more readable.
        (reverse (car new))))))
#+end_src

The =zz/refresh-reveal-prez= function makes use of the above to perform the presentation export, refresh and update. You can use it by adding an after-save hook like this (add at the end of the file):

#+begin_example
,* Local variables :ARCHIVE:noexport:
# Local variables:
# eval: (add-hook! after-save :append :local (zz/refresh-reveal-prez))
# end:
#+end_example

*Note #1:* This is specific to my OS (macOS) and the browser I use (Brave). I will make it more generic in the future, but for now feel free to change it to your needs.

*Note #2:* the presentation must be already open in the browser, so you must run "Export to reveal.js -> To file and browse" (=C-c C-e v b=) once by hand.

#+begin_src emacs-lisp
(defun zz/refresh-reveal-prez ()
  ;; Export the file
  (org-re-reveal-export-to-html)
  (let* ((slide-list (zz/org-current-headline-number))
         (slide-str (string-join (mapcar #'number-to-string slide-list) "-"))
         ;; Determine the filename to use
         (file (concat (file-name-directory (buffer-file-name))
                       (org-export-output-file-name ".html" nil)))
         ;; Final URL including the slide number
         (uri (concat "file://" file "#/slide-" slide-str))
         ;; Get the document title
         (title (cadar (org-collect-keywords '("TITLE"))))
         ;; Command to reload the browser and move to the correct slide
         (cmd (concat
"osascript -e \"tell application \\\"Brave\\\" to repeat with W in windows
set i to 0
repeat with T in (tabs in W)
set i to i + 1
if title of T is \\\"" title "\\\" then
  reload T
  delay 0.1
  set URL of T to \\\"" uri "\\\"
  set (active tab index of W) to i
end if
end repeat
end repeat\"")))
    ;; Short sleep seems necessary for the file changes to be noticed
    (sleep-for 0.2)
    (call-process-shell-command cmd)))
#+end_src

** Programming Org

Trying out [[https://github.com/ndwarshuis/org-ml][org-ml]] for easier access to Org objects.

#+begin_src emacs-lisp :tangle packages.el
(package! org-ml)
#+end_src
#+begin_src emacs-lisp
(use-package! org-ml
  :after org)
#+end_src

I'm also testing [[https://github.com/alphapapa/org-ql][org-ql]] for structured queries on Org documents.

#+begin_src emacs-lisp :tangle packages.el
(package! org-ql)
#+end_src
#+begin_src emacs-lisp
(use-package! org-ql
  :after org)
#+end_src

This function returns a list of all the headings in the given file which have the given tags.

#+begin_src emacs-lisp
(defun zz/headings-with-tags (file tags)
  (let ((headings (org-ql-select file
                    `(tags-local ,@tags))))
    (mapconcat
     (lambda (l) (format "- %s" l))
     (mapcar
      (lambda (h)
        (let ((title (car (org-element-property :title h))))
          (org-link-make-string
           (format "file:%s::*%s"
                   file title)
           title)))
      headings) "\n")))
#+end_src

This function returns a list of all the headings in the given file which match the tags of the current heading.

#+begin_src emacs-lisp
(defun zz/headings-with-current-tags (file)
  (let ((tags (s-split ":" (cl-sixth (org-heading-components)) t)))
    (zz/headings-with-tags file tags)))
#+end_src

* Coding
*** General Coding

Tangle-on-save has revolutionized my literate programming workflow. It automatically runs =org-babel-tangle= upon saving any org-mode buffer, which means the resulting files will be automatically kept up to date. For a while I did this by manually adding =org-babel-tangle= to the =after-save= hook in Org mode, but now I use the [[https://github.com/yilkalargaw/org-auto-tangle][org-auto-tangle]] package, which does this asynchronously and selectively for each Org file where it is desired.

Setting  =org-auto-tangle-default= to a positive value automatically tangle the file on save. I don't want to tangle automatically every =org= file I work on, so the option is disable. Instead, I add the option =#+auto_tangle: t= in myacea org file.

#+begin_src emacs-lisp :tangle packages.el
(package! org-auto-tangle)
#+end_src
#+begin_src emacs-lisp
(use-package! org-auto-tangle
  :defer t
  :hook (org-mode . org-auto-tangle-mode)
  :config
  (setq org-auto-tangle-default nil))
#+end_src

Some useful settings for LISP coding - =smartparens-strict-mode= to enforce parenthesis to match. I map =M-(= to enclose the next expression as in =paredit= using a custom function. Prefix argument can be used to indicate how many expressions to enclose instead of just 1. E.g. =C-u 3 M-(= will enclose the next 3 sexps.

#+begin_src emacs-lisp
(defun zz/sp-enclose-next-sexp (num)
  (interactive "p")
  (insert-parentheses (or num 1)))

(after! smartparens
  (add-hook! (clojure-mode
              emacs-lisp-mode
              lisp-mode
              cider-repl-mode
              racket-mode
              racket-repl-mode) :append #'smartparens-strict-mode)
  (add-hook! smartparens-mode :append #'sp-use-paredit-bindings)
  (map! :map (smartparens-mode-map smartparens-strict-mode-map)
        "M-(" #'zz/sp-enclose-next-sexp))
#+end_src


*** Julia
I use julia-repl. I get the master branch because sometime doom is stuck to older versions.
#+begin_src emacs-lisp :tangle packages.el
(package! julia-repl
  :recipe (:host github
           :repo "tpapp/julia-repl"
           :branch "master")
)
#+end_src

I heavily use unicode while editing jl files
  #+begin_src emacs-lisp
    (defun setup-unicode ()
      "Unicode input for the buffer."
      (interactive)
      (company-mode)                        ; using company-mode
      (setq-local company-backends '(company-math-symbols-unicode))
      (setq-local company-minimum-prefix-length 1)
      (setq-local company-idle-delay 0))
  #+end_src



#+begin_src emacs-lisp
(after! julia-mode
  (setq path-to-julia-repl "/usr/local/bin/julia")
  (add-hook! julia-mode-hook
             #'julia-repl-mode
             (setup-unicode))
)
#+end_src

I compile a system image that I then use inside emacs.
#+begin_src emacs-lisp
;; Meke sure that the file is present
(cond (IS-MAC
      (setq julia-repl-switches "--sysimage /Users/gragusa/.julia/.ds/ds")
      (setq inferior-julia-args "--sysimage /Users/gragusa/.julia/.ds/ds")
      ))

(cond (IS-LINUX
      (setq julia-repl-switches "--sysimage /home/gragusa/.julia/.ds/ds")
      (setq inferior-julia-args "--sysimage /home/gragusa/.julia/.ds/ds")
      ))

#+end_src

#+begin_src emacs-lisp
(setq inferior-julia-program-name "/usr/local/bin/julia")
#+end_src


  - To use lsp features I need to install julia-lsp
    #+begin_src emacs-lisp :tangle packages.el
    (package! lsp-julia)
    #+end_src

**** Julia-repl
- I use vterm terminal emulation
#+begin_src emacs-lisp
(after! julia-repl
  (julia-repl-set-terminal-backend 'vterm)
)
#+end_src
- Configure TAB to complete in VTERM (Not really a Julia-repl thing!)
#+begin_src emacs-lisp
(map! :after vterm
      :map vterm-mode-map
      :i [tab] #'vterm--self-insert
      :i "TAB" #'vterm--self-insert
)
#+end_src

**** LSP
#+begin_src emacs-lisp
;; Required https://github.com/non-Jedi/lsp-julia/issues/35
(setq lsp-enable-folding t)
;;1. Symbol highlighting
(setq lsp-enable-symbol-highlighting t)
;; 2. lsp-ui-doc - on hover dialogs. * disable via
(setq lsp-ui-doc-enable t)
(setq lsp-ui-doc-show-with-cursor t)
;; disable mouse hover (keep cursor hover)
(setq lsp-ui-doc-show-with-mouse nil)
(setq lsp-ui-doc-use-webkit t)
(setq lsp-ui-doc-delay 0.4)
(setq lsp-ui-doc-max-width 96)
;;3. Lenses
(setq lsp-lens-enable t)
;; 4. Headerline
(setq lsp-headerline-breadcrumb-enable nil)
;; 5. Sideline code actions * disable whole sideline via
(setq lsp-ui-sideline-enable t)
;; hide code actions
(setq lsp-ui-sideline-show-code-actions nil)
;; Sideline hover symbols * disable whole sideline via
(setq lsp-ui-sideline-enable t)
;; hide only hover symbols
(setq lsp-ui-sideline-show-hover nil)
#+end_src




*** R

*** Latex

* Other tools

- Use Emacs [[https://github.com/tecosaur/emacs-everywhere][Everywhere]]!

  #+begin_src emacs-lisp :tangle no
(package! emacs-everywhere :pin nil)
  #+end_src
  #+begin_src emacs-lisp :tangle no
(use-package! emacs-everywhere
  :config
  (setq emacs-everywhere-major-mode-function #'org-mode))
  #+end_src

- Trying out [[https://magit.vc/manual/magit/Repository-List.html][Magit's multi-repository abilities]]. This stays in sync with the git repo list used by my [[https://github.com/zzamboni/elvish-themes/blob/master/chain.org#bonus-displaying-the-status-of-several-git-repos-at-once][chain:summary-status]] Elvish shell function by reading the file every time =magit-list-repositories= is called, using =defadvice!=. I also customize the display to add the =Status= column.

  #+begin_src emacs-lisp :tangle no
(after! magit
  (setq zz/repolist
        "~/.elvish/package-data/elvish-themes/chain-summary-repos.json")
  (defadvice! +zz/load-magit-repositories ()
    :before #'magit-list-repositories
    (setq magit-repository-directories
          (seq-map (lambda (e) (cons e 0)) (json-read-file zz/repolist))))
  (setq magit-repolist-columns
        '(("Name" 25 magit-repolist-column-ident nil)
          ("Status" 7 magit-repolist-column-flag nil)
          ("B<U" 3 magit-repolist-column-unpulled-from-upstream
           ((:right-align t)
            (:help-echo "Upstream changes not in branch")))
          ("B>U" 3 magit-repolist-column-unpushed-to-upstream
           ((:right-align t)
            (:help-echo "Local changes not in upstream")))
          ("Path" 99 magit-repolist-column-path nil))))
  #+end_src

- I prefer to use the GPG graphical PIN entry utility. This is achieved by setting =epg-pinentry-mode= (=epa-pinentry-mode= before Emacs 27) to =nil= instead of the default ='loopback=.

  #+begin_src emacs-lisp :tangle no
(after! epa
  (set (if EMACS27+
           'epg-pinentry-mode
         'epa-pinentry-mode) ; DEPRECATED `epa-pinentry-mode'
       nil))
  #+end_src

- I find =iedit= absolutely indispensable when coding. In short: when you hit =Ctrl-;=, all occurrences of the symbol under the cursor (or the current selection) are highlighted, and any changes you make on one of them will be automatically applied to all others. It's great for renaming variables in code, but it needs to be used with care, as it has no idea of semantics, it's  a plain string replacement, so it can inadvertently modify unintended parts of the code.

  #+begin_src emacs-lisp :tangle packages.el
(package! iedit)
  #+end_src
  #+begin_src emacs-lisp
(use-package! iedit
  :defer
  :config
  (set-face-background 'iedit-occurrence "Magenta")
  :bind
  ("C-;" . iedit-mode))
  #+end_src



- Add "unfill" commands to parallel the "fill" ones, bind ~A-q~ to =unfill-paragraph= and rebind ~M-q~ to the =unfill-toggle= command, which fills/unfills paragraphs alternatively.

  #+begin_src emacs-lisp :tangle no
(package! unfill)
  #+end_src
  #+begin_src emacs-lisp :tangle no
(use-package! unfill
  :defer t
  :bind
  ("M-q" . unfill-toggle)
  ("A-q" . unfill-paragraph))
  #+end_src

- The [[https://github.com/bastibe/annotate.el][annotate]] package is nice - allows adding annotations to files without modifying the file itself.

  #+begin_src emacs-lisp :tangle no
(package! annotate)
  #+end_src

- [[https://github.com/csrhodes/gift-mode][gift-mode]] for editing quizzes in [[https://docs.moodle.org/39/en/GIFT_format][GIFT format]].
  #+begin_src emacs-lisp :tangle no
(package! gift-mode)
  #+end_src

#+begin_src emacs-lisp :tangle packages.el
(package! exec-path-from-shell)
#+end_src

